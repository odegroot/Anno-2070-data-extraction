# coding=utf_8
'''
Generates a JSON file with the properties of all academy research projects.

Created on Dec 18, 2011

@author: Oscar de Groot (Grilse)
'''

import collections # OrderedDict preserves the order of the keys by the order in which they are inserted. A regular dict does not do this.
import configparser
import guid_to_icon
import json
import os
import re
import xml.etree.ElementTree as ET

__game_version  = "Anno 2070 v1.02"
__out_encoding  = 'utf_8'
__model_ref_txt = 'https://github.com/odegroot/Anno-2070-data-extraction/blob/master/src/doc/academy_research_model_reference.txt'

__project_root  = os.path.join('..', '..')
__rda_folder    = os.path.join(__project_root, "src", "rda")
__out_folder    = os.path.join(__project_root, "target")
__features_xml  = os.path.join(__rda_folder, "patch3", "data", "config", "features", "features.xml")
__eng_folder    = os.path.join(__rda_folder, "eng3", "data", "loca", "eng", "txt")

__regex_guidname= re.compile(r'\[GUIDNAME (?P<GUID>\d+)\]')

__guid_to_icon = guid_to_icon.get_guid_to_icon_dict()

# Maps the ItemQuality in features.xml to the number of stars displayed in-game.
__ItemQuality_stars = {
    'D' : 0,
    'C' : 1,
    'B' : 2,
    'A' : 3,
    None: 3
}

def main():
    eng = get_localization('eng')
    
    out_json = collections.OrderedDict()
    out_json['encoding'] = __out_encoding
    out_json['source'] = 'This file was automatically generated by ' + _get_current_py_filename()
    out_json['source.url'] = 'https://github.com/odegroot/Anno-2070-data-extraction'
    out_json['game_version'] = __game_version
    out_json['model_reference'] = __model_ref_txt
    out_json['data'] = get_research_project_dicts(eng)
    
    with open(_get_json_path(), mode="w", encoding=__out_encoding, newline='\n') as json_file:
        json.dump(out_json, fp=json_file, indent=2, separators=(',', ': ')) # separators: replace ', ' with ',' to prevent trailing whitespace.
        
    print("done.")

def _get_current_py_filename():
    '''Returns the filename of the python file that is currently executing.'''
    # __file__.rpartition(os.sep) --> (path, os.sep, file)
    py_filename = __file__.rpartition(os.sep)[2]
    
    return py_filename

def _get_json_path():
    '''
    Returns the path to the JSON file that will contain the result of this script.
    
    The JSON filename is the same as the script that generates it, but with the extension ".json", and with a version number included.
    Example: "academy_research_v0.1.json"
    The file is placed in "{project_root}/target/"
    '''
    # this_py_filename.rpartition('.') --> (filename_without_extension, '.', 'py')
    filename_without_extension = _get_current_py_filename().rpartition('.')[0]
    json_filename = filename_without_extension + '.json'
    json_path = os.path.join(__out_folder, json_filename)
    
    return json_path

def get_research_project_dicts(eng):
    '''
    Returns a list of dictionaries. Each dictionary represents one academy research project.
    
    An overview of features.xml is available at {project_root}/src/doc/features_overview.xml
    A description of the research project dictionary is included in the generated JSON file.
    '''
    projects = []
    
    # Structure of features.xml
    # All research-related stuff is in the toplevel group named "Science".
    # The "Science" group has four subgroups: Modules, Prototypes, Devs and DiscoveryPools.
    #  
    category_groups = []
    for group in ET.parse(__features_xml).findall('.//Group'):
        if (group.findtext('Name') == 'Devs'):
            category_groups = group.findall('Groups/Group') # find all subgroups of the Devs-group.
            break
        
    if (category_groups == []):
        raise Exception("Could not find the Devs-group in features.xml.")
    
    for category_group in category_groups:
        category = category_group.findtext('Name')
        category_project_count = 0
        
        for project_asset in category_group.findall('Assets/Asset'):
            projects.append(_get_research_project_dict(project_asset, eng, category))
            category_project_count += 1
        
        for subcategory_group in category_group.findall('Groups/Group'):
            subcategory = subcategory_group.findtext('Name')
            for project_asset in subcategory_group.findall('Assets/Asset'):
                projects.append(_get_research_project_dict(project_asset, eng, category, subcategory))
                category_project_count += 1
        
        # print('Category {:10} has {:>2} projects.'.format(category, category_project_count))
    
    return projects

def _get_research_project_dict(project_asset, eng, category, subcategory=None):
    '''
    Returns a single research project dictionary, based on its <Asset>...</Asset>. 
    
    Documentation of the keys in this dictionary and their meaning is stored in a separate document: {}
    '''.format(__model_ref_txt)
    
    project = collections.OrderedDict() 
    
    # GUID ----------------------------------
    GUID = project_asset.findtext('Values/Standard/GUID')
    project['GUID'] = int(GUID)
    project['Name'] = project_asset.findtext('Values/Standard/Name')
    
    # Name.eng ------------------------------------
    name_eng = eng[GUID]
    # Localization strings can refer to each other. Follow these references and display the final result.
    # Replace "Blueprint: [GUIDNAME 10087]"
    # With    "Blueprint: Hydroelectric power plant"
    if (__regex_guidname.search(name_eng)):
        inner_GUID = __regex_guidname.search(name_eng).group('GUID')
        name_eng = __regex_guidname.sub(eng[inner_GUID], name_eng, count=1)
    project['Name.eng'] = name_eng
    # description.eng -----------------------------------------
    # The tooltip descriptions are linked to GUIDs that are in the 10,000,000 - 19,999,999 range.
    # It appears that the game simply adds 10M to the normal GUID, but I have not found an explicit confirmation of this.
    # So I'm just assuming that this is the case.
    project['description.eng'] = eng[str(int(GUID)+10000000)]
    
    # category ------------------------------------------------
    project['category'] = category
    # subcategory ---------------------------------------------
    if subcategory != None: project['subcategory'] = subcategory
    
    # ItemQuality -----------------------------------------------
    project['ItemQuality'] = project_asset.findtext('Values/Item/ItemQuality')
    # ItemQuality.stars -----------------------------------------
    project['ItemQuality.stars'] = __ItemQuality_stars[project['ItemQuality']]
    
    # icon.base -----------------------------------------------
    project['icon.base'] = __guid_to_icon[GUID]['icon.base']
    # icon.overlay --------------------------------------------
    if 'icon.overlay' in __guid_to_icon[GUID]:
        project['icon.overlay'] = __guid_to_icon[GUID]['icon.overlay']
    
    # effect.ActiveEcoEffect.* ---------------------------------------------
    add_effect(project, project_asset.find('Values/MaintenanceCostUpgrade/ActiveEcoEffect'))
    # effect.InActiveEcoEffect.* ---------------------------------------------
    add_effect(project, project_asset.find('Values/MaintenanceCostUpgrade/InActiveEcoEffect'))
    # effect.ActiveEnergyCost.* ---------------------------------------------
    add_effect(project, project_asset.find('Values/MaintenanceCostUpgrade/ActiveEnergyCost'))
    # effect.InActiveEnergyCost.* ---------------------------------------------
    add_effect(project, project_asset.find('Values/MaintenanceCostUpgrade/InActiveEnergyCost'))
    
    return project

def add_effect(project, xml_element):
    if xml_element == None:
        return
    
    tag = xml_element.tag
    value = int(xml_element.findtext('Value'))
    if xml_element.findtext('Percental') == '1':
        percental = True
    elif xml_element.findtext('Percental') == '0':
        percental = False
    elif xml_element.findtext('Percental') == None:
        percental= False
    else:
        raise Exception(project['GUID'] + ' has unsupported value for <Percental>: ' + xml_element.findtext('Percental'))
    project['effect.{}.Value'.format(tag)] = value
    project['effect.{}.Percental'.format(tag)] = percental
    project['effect.{}.text'.format(tag)] = "{:+}".format(value) + ('%' if percental else '')
    

def get_localization(lang):
    '''
    Parses an Anno 2070 properties guids_file, such as guids.txt.
    
    Returns a dictionary of the key/value pairs defined in the guids_file.
    '''
    if (lang != 'eng'):
        raise Exception('Only English localization is currently supported.')
    
    config = configparser.ConfigParser()
    for filename in ['guids.txt', 'interface.txt', 'tt_normal.txt']:
        # The text files are encoded in UTF-16. Its endianness is automatically detected by open(), using the BOM.
        with open(os.path.join(__eng_folder, filename), encoding="utf_16") as file:
            config.read_file(_add_section_header(file, 'DEFAULT'), source=filename)
    
    return config['DEFAULT']

def _add_section_header(properties_file, header_name):
    '''
    configparser.ConfigParser requires at least one section header in a properties file.
    The Anno 2070 properties files don't have section headers, so a header is added on the fly.
    '''
    yield '[{}]\n'.format(header_name)
    for line in properties_file:
        yield line
    
if __name__ == "__main__":
    main()